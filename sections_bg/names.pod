=encoding utf8

=head1 Имена

Z<names>

X<имена>
X<идентификатори>

I<Имената> (или I<идентификаторите>) са навсякъде в Perl програмите: променливи, функции, пакети, класове,
дори файлови манипулатори. Всички тези имена започват с буква или долна черта. След това е допустима произволна
комбинация от букви, цифри и долни черти. 
Когато е в сила правилото за C<utf8>N<"Прагмите" като C<utf8> включват правила,
които парсърът и компилаторът спазват. (бел. прев.)> в изходния код (L<unicode>),
можете да използвате всеки буквено-числов символ от UTF-8 в идентификаторите.
Ето някои валидни идентификатори в Perl:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # use utf8; разрешава използването на уникод
    package Ingy::DE<ouml>t::Net;

=end programlisting

А тези идентификатори са невалидни в Perl:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<намиране на символи>

I<Имената съществуват най-вече за удобство на програмиста>. Това важи само
за буквени имена, каквито се срещат във вашия изходен код, като C<sub
fetch_pie> или C<my $waffleiron>. Но единствено парсърът на Perl може да прилага правилата
за имена на идентификаторите.

Динамичният характер на Perl ви позволява да ползвате имена,
генерирани по време на изпълнение, или взети от входа на програмата.
Този метод за I<намиране на символи> предоставя гъвкавост, донякъде за сметка на сигурността.
По-специално, непрякото извикване на функции или методи или търсенето на символи
в пространство от имена ви дава възможност да заобиколите парсъра на Perl.

Такава практика може да доведе до доста объркващ код. Както Марк Джейсън Доминус препоръчва
много удачноN<U<http://perl.plover.com/varvarname.html>>, ползвайте хеш (L<hashes>)
или сложни структури от данни (L<nested_data_structures>).

=head2 Имена на променливи и Знаци за тип

X<променливи; имена>
X<скаларни променливи>
X<променливи; скалари>
X<скалари>
X<масиви>
X<променливи; скалари>
X<хешове>
X<променливи; хешове>
X<знак за тип>

I<Имената на променливите> винаги започват със I<знак за тип> (или символ),
указващ типа стойност на променливата. I<Скаларните променливи> (L<scalars>) използват
знака за долар (C<$>). I<Масивите> (L<arrays>) се обозначават с маймунка (C<@>).
Пред I<хешовете> (L<hashes>) се слага знак за процент (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Тези знаци предоставят видимо пространство от имена за променливите.
Така е възможно--макар и объркващо--да се декларират множество променливи с еднакво име и от различни типове:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Perl ще разчете правилно тези инструкции, но същото не важи и за хората, които ще видят този код.

X<променящ се знак за тип>

Знаците за тип в Perl 5 са I<променящи се знаци за тип>. Контекстът определя количеството
елементи или типа данни, които ще получите. А от знака за тип зависи какво ще направите
с данните от променливи. Например, за да достъпите даден елемент от масив или хеш, трябва да
ползвате знака за скалар (C<$>):

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

Паралелът със значението на контекста е важен. Използването на скаларен елемент
от съвкупност от данни като I<lvalue> (обектът на присвояване, вляво от знака C<=>),
прилага скаларен контекст (L<context_philosophy>) на I<rvalue>
(присвоената стойност, вдясно от знака C<=>).

X<отрязъци>

Съответно, при достъпването на множество елементи от хеш или масив--наричано още I<отрязване>--
се използва символът маймунка (C<@>), който прилага списъчен контекстN<...дори ако самият списък 
съдържа нула или един елемента>:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

Най-сигурният начин да се определи типа на една променлива--скалар, масив или хеш--
е като се види какви процеси се изпълняват с нея. Скаларите поддържат всички основни процеси--
низови, числови и булеви. Масивите осъществяват индексиран достъп посредством квадратни скоби.
А хешовете имат достъп с ключ чрез фигурни скоби.

=head2 Пространства от имена

X<fully-qualified name>
X<пространства от имена>

Perl предоставя механизъм за групиране на сходни функции и променливи в техни собствени
именовани пространства--I<пространства от имена> (L<packages>). Пространство от имена
е именована колекция от символи. В Perl са разрешени йерархични пространства от имена. В тях
имената са обединени в двойка колони (C<::>), където C<DessertShop::IceCream> се отнася за логическа
колекция от свързани променливи и функции (като C<scoop()> и C<pour_hot_fudge()>).

В едно пространство от имена може да използвате съкратено име за неговите елементи.
Извън пространството от имена посочвате негов елемент само с I<пълното му име>.
Например, в пространството на C<DessertShop::IceCream>, C<add_sprinkles()> е същата функция,
както C<DessertShop::IceCream::add_sprinkles()> извън това пространство.

Стандартните правила за именоване са приложими към имената на пакети. А дефинираните
от потребителя пакети винаги започват с главна буква, по подразбиране. Ядрото на Perl
съхранява имената на пакети с малка буква като правила на ядрото (L<pragmas>), като например
C<strict> и C<warnings>. Тази политика е продиктувана най-вече от принципите на общността.

Всички пространства от имена в Perl 5 са видими глобално. Когато Perl търси символ
в C<DessertShop::IceCream::Freezer>, той гледа в C<main::> таблицата със символи
за символа, представляващ пространството от имена C<DessertShop::>. После гледа в него
за пространството C<IceCream::>, и т.н. Пространството C<Freezer::> е видимо и извън
пространството C<IceCream::>. 
All namespaces in Perl 5 are globally visible. When Perl looks up a symbol in
C<DessertShop::IceCream::Freezer>, it looks in the C<main::> symbol table for a
symbol representing the C<DessertShop::> namespace, then in there for the
C<IceCream::> namespace, and so on. The C<Freezer::> is visible from outside of
the C<IceCream::> namespace. The nesting of the former within the latter is
only a storage mechanism, and implies nothing further about relationships
between parent and child or sibling packages. Only a programmer can make
I<logical> relationships between entities obvious--by choosing good names and
organizing them well.
