=encoding utf8

=head1 Типове оператори

Z<operator_types>

Операторите в Perl указват стойностния контекст, в който аргументите
ще бъдат изпълнени.  За да изберете правилния оператор, трябва да
разберете стойностите на аргументите, които подавате, както и
стойността, която очаквате да получите.

=head2 Числови оператори

Z<numeric_operators>

X<оператори; числов>
X<оператори; аритметичен>
X<оператори; C<+>>
X<C<+>; числов оператор>
X<оператори; C<->>
X<C<->; числов оператор>
X<оператори; C<*>>
X<C<*>; числов оператор>
X<оператори; C</>>
X<C</>; числов оператор>
X<оператори; C<**>>
X<C<**>; числов оператор>
X<оператори; C<%>>
X<C<%>; числов оператор>
X<оператори; C<+=>>
X<C<+=>; числов оператор>
X<оператори; C<-=>>
X<C<-=>; числов оператор>
X<оператори; C<*=>>
X<C<*=>; числов оператор>
X<оператори; C</=>>
X<C</=>; числов оператор>
X<оператори; C<**=>>
X<C<**=>; числов оператор>
X<оператори; C<%=>>
X<C<%=>; числов оператор>
X<оператори; C<-->>
X<C<-->; числов оператор>

Числовите оператори налагат числов контекст върху своите
аргументи. Операторите, които правят това, са стандартните аритметични
оператори като събиране (C<+>); изваждане (C<->); умножение (C<*>);
деление (C</>); повдигане на степен (C<**>); деление по модул (C<%>);
техните варианти, които работят директно върху променливата (C<+=>,
C<-=>, C<*=>, C</=>, C<**=>, и C<%=>); и postfix и prefix автоматично
намаляване на (C<-->).

Операторът за автоматично увеличение има специално поведение, когато
се прилага върху низови стойности (L<auto_increment_operator>).

X<оператори; C<==>>
X<оператори; C<!=>>
X<<< оператори; C<< E<lt> >> >>>
X<<< оператори; C<< E<gt> >> >>>
X<<< оператори; C<< E<lt>= >> >>>
X<<< оператори; C<< E<gt>= >> >>>
X<<< оператори; C<< E<lt>=E<gt> >> >>>

X<C<!=>; оператор за числово сравнение>
X<C<==>; оператор за числово сравнение>
X<<< C<< E<gt> >>; оператор за числово сравнение >>>
X<<< C<< E<lt> >>; оператор за числово сравнение >>>
X<<< C<< E<gt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>=E<gt> >>; оператор за числово сравнение >>>

Някои оператора за сравнение налагат числов контекст върху своите
аргументи. Това са оператора за числово равенство (C<==>); за числово
неравенство (C<!=>); по-голямо (C<< E<gt> >>); по-малко (C<< E<lt>
>>); по-голямо или равно (C<< E<gt>= >>); по-малко или равно (C<<
E<lt>= >>); и  сортиращият оператор за сравнение (C<< E<lt>=E<gt>
>>()).

=head2 Оператори за работа с низове

X<оператори; низ>
X<низове; оператори>
X<оператори; C<=~>>
X<C<=~>; низов оператор>
X<оператори; C<!~>>
X<C<!~>; низов оператор>
X<оператори; C<.>>
X<C<.>; низов оператор>

Операторите за низове налагат низов контекст върху своите
аргументи. Операторите за положително и отрицателно търсене в низ,
чрез регулярен израз, (C<=~> и C<!~>), както и оператора за конкатация
(C<.>) работят с низове.

X<оператори; C<eq>>
X<оператори; C<ne>>
X<оператори; C<gt>>
X<оператори; C<lt>>
X<оператори; C<ge>>
X<оператори; C<le>>
X<оператори; C<cmp>>
X<C<eq>; оператор за сравняване на низове>
X<C<ne>; оператор за сравняване на низове>
X<C<gt>; оператор за сравняване на низове>
X<C<lt>; оператор за сравняване на низове>
X<C<ge>; оператор за сравняване на низове>
X<C<le>; оператор за сравняване на низове>
X<C<cmp>; оператор за сравняване на низове>

Оператори за сравнение на низове налагат низов контекст върху своите
аргументи. Това са операторизе за равенство между низове (C<eq>);
неравенство между низове (C<ne>); по-голямо (C<gt>); по-малко (C<lt>);
по-голямо или равно (C<ge>); по-малко или равно (C<le>); и сортиращият
низов оператор за сравнение (C<cmp>).

=head2 Логически оператори

X<оператори; логически>
X<оператори; C<&&>>
X<оператори; C<and>>
X<оператори; C<||>>
X<оператори; C<or>>
X<оператори; C<//>>
X<оператори; C<?:>>
X<оператори; C<!>>
X<оператори; C<not>>
X<оператори; C<xor>>
X<C<&&>; логически оператор>
X<C<and>; логически оператор>
X<C<||>; логически оператор>
X<C<or>; логически оператор>
X<C<//>; логически оператор>
X<C<?:>; логически оператор>
X<C<!>; логически оператор>
X<C<not>; логически оператор>
X<C<xor>; логически оператор>
X<оператори; defined-or>
X<defined-or; логически оператор>
X<short-circuiting; ранно прекъсване>

Логическите оператори налагат булев контекст върху своите
аргументи. Логически оператори са C<&&>, C<and>, C<||>, и
C<or>. Всичките се използват в infix позиция и също така всичките
I<прекъсват възможно най-ранно> (L<short_circuiting>). Операторите
думи имат по-нисък приоритет от другата им форма, която се пише чрез
пунктуационни знаци.

Операторът defined-or, C<//>, тества дали аргумента му е I<дефиниран>. Съвсем различно от операторът C<||>, който тества I<истинностната> стойност на аргументите си, операторът C<//> връща истинностна стойност истина дори когато аргумента му има числова стойност нула или е празен низ. Това е лесен метод за писане на забавен код, който задава стойност по подразбиране на променливи:

=begin programlisting

    sub name_pet
    {
        my $name = shift // 'Шаро';
        ...
    }

=end programlisting

X<C<?:>; условен оператор>

Условния оператор (C<?:>) работи с три аргумента. Първият от
аргументите се изпълнява в булев контекст и ако той е истина, връща
резултата от втория аргумент, иначе връща резултата от третия
аргумент:

=begin programlisting

    my $truthiness = $value ? 'истина' : 'неистина';

=end programlisting

Префиксните оператори C<!> и C<not> връщат истина, ако аргумента им
има булева стойност неистина и връщат неистина, ако аргумента им има
булева стойност истина. Операторът C<not> е с по-нисък приоритет от
C<!>.

Операторът C<xor> е инфикс оператор, който връща резултата от
прилагането на изключващо „или“ към аргументите си.

=head2 Побитови оператори

X<оператори; побитово>
X<<< оператори; C<< E<lt>E<lt> >> >>>
X<<< оператори; C<< E<gt>E<gt> >> >>>
X<оператори; C<&>>
X<оператори; C<|>>
X<оператори; C<^>>
X<оператори; C<&=>>
X<оператори; C<|=>>
X<оператори; C<^=>>
X<<< оператори; C<< E<lt>E<lt>= >> >>>
X<<< оператори; C<< E<gt>E<gt>= >> >>>

X<<< C<< E<lt>E<lt> >>; побитови оператори >>>
X<<< C<< E<gt>E<gt> >>; побитови оператори >>>

X<C<&>; побитови оператори>
X<C<|>; побитови оператори>
X<C<^>; побитови оператори>
X<C<&=>; побитови оператори>
X<C<|=>; побитови оператори>
X<C<^=>; побитови оператори>
X<<< C<< E<lt>E<lt>= >>; побитови оператори >>>
X<<< C<< E<gt>E<gt>= >>; побитови оператори >>>

Побитовите оператори работят върху нулите и единиците, с които
вътрешно са представени техните аргументи. Тяхното използване не се
среща често. Побитови оператори са операторът за изместване наляво
(C<< << >>); операторът за изместване надясно (C<< >> >>); побитово
„и“ (C<&>); побитово „или“ (C<|>); и побитово изключващо „или“
(C<^>). Вариантите, които работят директно върху променливата, са C<<
<<= >>, C<< >>= >>, C<&=>, C<|=>, и C<^=>.

=head2 Специални оператори

Z<auto_increment_operator>

X<оператори; автоматично увеличаване>
X<автоматично увеличаване>
X<оператори; C<++>>
X<C<++>; оператор за автоматично увеличаване>

Операторът за автоматично увеличаване има особено поведение. Когато се
използва върху стойност с числов компонент(има нещо, което прилича на
число в началото на низа, ако стойността е низ) (L<cached_coercions>),
операторът ще третира стойността като число и ще увеличи това число с
1. Ако стойността не е число, а низ без числов компонент в началото,
то операторът увеличава стойността на низа, така че C<a> става C<b>,
C<zz> става C<aaa>, а C<a9> става C<b0>.

=begin programlisting

    my $num = 1;
    my $str = 'a';

    $num++;
    $str++;
    is( $num,   2, 'числово увеличаване' );
    is( $str, 'b', 'низово увеличаване'  );

    no warnings 'numeric';
    $num += $str;
    $str++;

    is( $num, 2, 'числово събиране с $str'    );
    is( $str, 1, '... интерпретира $str като число' );

=end programlisting

X<оператори; повторение>
X<оператори; C<x>>
X<C<x>; оператор за повторение>

Операторът за повторение (C<x>) е инфикс оператор със сложно
поведение. В списъчен контекст, когато му се подаде списък, операторът
ще повтори списъка толкова пъти, колкото е указано чрез втория
аргумент. В списъчен контекст, когато му се подаде скаларна стойност,
оператора връща низ съдържащ първия аргумент съединен толкова пъти със
себе си, колкото е посочено от втория аргумент.

В скаларен контекст, операторът винаги връща низ от повторенията на
първия аргумент. Например:

=begin programlisting

    my @scheherazade = ('нощи') x 1001;
    my $calendar     =  'нощи'  x 1001;
    my $cal_length   =  length $calendar;

    is( @scheherazade, 1001, 'повторен списък' );
    is( $cal_length,   1001 * length 'нощи',
                       'повторена дума' );

    my @schenolist   =  'нощи'  x 1001;
    my $calscalar    = ('нощи') x 1001;

    is( @schenolist, 1, 'имаме повторена дума' );
    is( length $calscalar,
        1001 * length 'nights', 'пак имаме повторена дума' );

=end programlisting

X<оператори; обхват>
X<обхват>
X<оператори; C<..>>
X<C<..>; оператор за обхват>

Инфикс операторът за I<обхват> (C<..>) връща списък в списъчен
контекст:

=begin programlisting

    my @cards = ( 2 .. 10, 'J', 'Q', 'K', 'A' );

=end programlisting

Той може да връща само списък от последователни стойности, като всяка е по-голяма от предходната.

X<operators; тригер>
X<тригер>
X<C<..>; тригер оператор>

В булев контекст, операторът за обхват се превръща в I<тригер>
оператор. Този оператор връща неистина, докато левият му аргумент не
стане истинен. Тогава оператора връща истина докато и десният аргумент
е истинен, след което стойността връщана от оператора е пак неистина
докато левият аргумент не стане отново истинен. Представете си
програма, която чете формално писмо:

=begin programlisting

    while (/Здравей, $user/ .. /Искрено,/)
    {
        say "> $_";
    }

=end programlisting

X<оператори; запетайка>
X<оператори; C<,>>
X<C<,>; оператор>
X<<< оператори; C<< =E<gt> >> >>>
X<<< C<< =E<gt> >>; оператор „дебелата запетайка“ >>>

Операторът I<запетайка> (C<,>) е инфикс оператор. В скаларен контекст
Perl изпълнява левият аргумент, а след това връща стойността от
изпълнението на десния аргумент. В списъчен контекст, Perl изпълнява
двата аргумента поред отляво-надясно.

„Дебелата запетайка“ (C<< => >>) автоматично третира „голи думи“
(такива, които не стоят в кавички), подадени като ляв аргумент, така
все едно са били поставени в кавички (L<hashes>).
