=encoding utf8

=head1 Характеристики на операторите

Z<operator_characteristics>
X<оператори; характеристики>

Всеки оператор има няколко важни характеристики, които определят
неговото поведение: броят на аргументите, върху които ще работи;
неговите отношения с други оператори; и неговите синтактични
възможности.

C<perldoc perlop> и C<perldoc perlsyn> предлагат огромно количество
информация относно операторите в Perl, но документацията предполага,
че вече сте запознати с някои детайли относно начина им на
работа. Основните идеи от компютърните науки може да звучат страшно в
началото, но след това ще видите, че ползването и разбирането им става
инстинктивно.

=head2 Приоритет

Z<precedence>
X<приоритет>

I<Приоритетът> на оператора определя кога Perl ще го обработи. Редът
на обработка започва от оператора с най-голям приоритет и завършва с
оператора с най-малък приоритет. Приоритетът на умножението е по-голям
от този на събирането, затова резултата на C<7 + 7 * 10> след
обработката ще бъде C<77>, а не C<140>.

За да накарате интерпретатора да изпълни някои оператори преди други,
трябва да оградите вътрешните изрази с кръгли скоби. В следния израз
C<(7 + 7) * 10>, ограждането на действието събиране кара
интерпретатора да извърши това действие преди умножението. Резултата е
C<140>.

C<perldoc perlop> съдържа таблица с приоритети на операторите.
Прочетете я, разберете я, но не си губете времето да я наизустявате.
По-добре използвайте прости изрази и ползвайте допълнително скоби за
да посочвате изрично намеренията си на тези, които четат кода Ви.

В случаите когато два оператора имат еднакъв приоритет, други фактори
като асоциативност (L<associativity>) и fixity (виж по-надолу) (L<fixity>) може да
укажат влияние на реда на изпълнение на операциите.

=head2 Асоциативност

Z<associativity>
X<асоциативност>
X<асоциативност; лява>
X<лява асоциативност>
X<асоциативност; дясна>
X<дясна асоциативност>

I<Асоциативността> на оператора определя дали той ще бъде изпълнен
отляво надясно или отдясно на ляво. Събирането е с лява асоциативност,
така че C<2 + 3 + 4> ще изпълни първо C<2 + 3>, а след това ще добави
C<4> към резултата. Повдигането на степен е с дясна асоциативност и
затова в израза C<2 ** 3 ** 4> първо ще се изпълни C<3 ** 4>, а след
това C<2> ще бъде повдигнато на степен 81.

Струва си времето да се запомни приоритетът и асоциативността на често
използваните математически оператори, но винаги ползвайте кръгли скоби
за да няма обърквания.

=begin sidebar

X<C<B::Deparse>>
X<приоритет; пояснителна>
X<асоциативност; пояснителна>

Модулът C<B::Deparse>, който е част от стандартната библиотека с
модули на Perl, е незаменим инструмент за дебъгване. Стартирайте
C<perl -MO=Deparse,-p> върху парче код за да видите как точно Perl
обработва различните оператори в зависимост от техния приоритет и
асоциативност. Флагът C<-p> добавя допълнителни групиращи скоби, които
често правят редът на изпълнение по-ясен.

Не забравяйте, че оптимизаторът на Perl ще опрости математически
операции като тези в предните примери. За да избегнете това,
използвайте променливи като например C<$x ** $y ** $z>.

=end sidebar

=head2 Arity

Z<arity>

X<arity; брой аргументи>
X<оператори; arity; брой на аргументите>
X<nullary>
X<unary>
X<binary>
X<trinary>
X<listary>

I<Arity> означава броя на аргументите, които един оператор приема.
I<Nullary> оператор е този, който не приема аргументи. I<Unary>
оператор е този, който приема само един аргумент. I<Binary> оператор
е този, който приема два аргумента. I<Trinary> оператор е този, който
приема три аргумента.  I<Listary> оператор е този, който работи върху
списък с аргументи. Документацията за всеки оператор и дадените
примери с него би трябвало да покажат ясно какъв брой аргументи може
да приеме.

Аритметичните оператори са бинарни оператори и обикновено са с лява асоциация.
В изразът C<2 + 3 - 4> първо се изпълнява действието събиране C<2 + 3>; събирането
и изваждането имат еднакъв приоритет, а редът на изпълнението им започва от най-левият
оператор, понеже са бинарни операции и с лява асоциация. Първо ще се изпълни най-левият
оператор с аргументи (C<2> и C<3>), а след това резултата ще участва като
аргумент към оператора C<-> и най-десния аргумент (C<4>).

Новаците в Perl често намират за объркващо използването на списъчни
оператори (особено извиквания на функции) и вложени изрази.  Въпреки,
че скобите често помагат, внимавайте с изрази като следния:

=begin programlisting

    # вероятно има бъг
    say ( 1 + 2 + 3 ) * 4;

=end programlisting

... което принтира стойността C<6> и (може би) резултата от всичко ще
е C<4> (върнатата стойност на C<say> умножена по C<4>). Парсърът на
Perl, с огромно щастие, ще интерпретира скобите като оператори
(L<fixity>), които ограждат аргументите на функцията C<say>, а не като
групиращи скоби, които променят реда на изпълнение.

=head2 Fixity

Z<fixity>
X<fixity>
X<operators; fixity>
X<infix>
X<fixity; infix>
X<prefix>
X<fixity; prefix>
X<postfix>
X<fixity; postfix>
X<circumfix>
X<fixity; circumfix>
X<postcircumfix>
X<fixity; postcircumfix> 

Терминът I<fixity> обозначава позицията на оператора относително на позицията на неговите аргументи:

X<C<.>; infix оператор>
X<C<.=>; infix оператор>
X<C<..>; infix оператор>
X<C<...>; infix оператор>
X<C<=~>; infix оператор>
X<C<!~>; infix оператор>
X<C<|>; infix оператор>
X<C<||>; infix оператор>
X<C<//>; infix оператор>
X<C<|=>; infix оператор>
X<C<||=>; infix оператор>
X<C<//=>; infix оператор>

=over 4

=item * I<Infix> операторите стоят между техните аргументи. Повечето
математически оператори са infix оператори, като например оператора за
умножение в C<$length * $width>.

X<C<\>; prefix оператор>
X<C<~>; prefix оператор>
X<C<++>; prefix оператор>
X<C<-->; prefix оператор>
X<C<+>; prefix оператор>
X<C<->; prefix оператор>
X<C<!>; prefix оператор>
X<C<!!>; prefix оператор>

=item * I<Prefix> операторите стоят пред своите аргументи. I<Postfix>
операторите следват след аргументите. Тези оператори обикновено
приемат само един аргумент, като например математическото отрицание
(C<-$x>), логическото отрицание (C<!$y>), и увеличение на променливата
след взимането на нейната стойност (C<$z++>).

X<C<()>; circumfix оператор>
X<C<{}>; circumfix оператор>
X<C<[]>; circumfix оператор>
X<C<//>; circumfix оператор>
X<C<``>; circumfix оператор>
X<C<''>; circumfix оператор>
X<C<"">; circumfix оператор>

=item * I<Circumfix> операторите обграждат своите оператори. Такива
оператори са оператора за изграждане на анонимен хеш (C<{ ... }>) и
операторите за цитиране (C<qq[ ... ]>).

X<C<()>; postcircumfix оператор>
X<C<{}>; postcircumfix оператор>
X<C<[]>; postcircumfix оператор>

=item * I<Postcircumfix> операторите са след някои аргументи и
обграждат други, като например операторите за достъп до елементите на
хеша или масива (C<$hash{$x}> и C<$array[$y]>).

=back
