=encoding utf8

=head1 Характеристики на операторите

Z<operator_characteristics>
X<оператори; характеристики>

Всеки оператор има няколко важни характеристики, които определят
неговото поведение: броят на аргументите, върху които ще работи;
неговите отношения с други оператори; и неговите синтактични
възможности.

C<perldoc perlop> и C<perldoc perlsyn> предлагат огромно количество
информация относно операторите в Perl, но документацията предполага,
че вече сте запознати с някои детайли относно начина им на
работа. Основните идеи от компютърните науки може да звучат страшно в
началото, но след това ще видите, че ползването и разбирането им става
инстинктивно.

=head2 Приоритет

Z<precedence>
X<приоритет>

I<Приоритетът> на оператора определя кога Perl ще го обработи. Редът
на обработка започва от оператора с най-голям приоритет и завършва с
оператора с най-малък приоритет. Приоритетът на умножението е по-голям
от този на събирането, затова резултата на C<7 + 7 * 10> след
обработката ще бъде C<77>, а не C<140>.

За да накарате някои оператори да се изпълнят преди други, трябва
оградите тях и техните аргументи с кръгли скоби. В израза C<(7 + 7) *
10>, ограждането на операцията за събиране казва на Perl да го извърши
преди операцията за умножение. Резултата е C<140>.

C<perldoc perlop> съдържа таблица с приоритети на операторите.
Прочетете я, разберете я, но не си губете времето да я наизустявате.
По-добре използвайте прости изрази и ползвайте допълнително скоби за
да посочвате изрично намеренията си на тези, които четат кода Ви.

В случаите когато два оператора имат еднакъв приоритет, други фактори
като асоциативност (L<associativity>) и fixity (виж по-надолу)
(L<fixity>) може да повлияят на реда на изпълнение на операциите.

=head2 Асоциативност

Z<associativity>
X<асоциативност>
X<асоциативност; лява>
X<лява асоциативност>
X<асоциативност; дясна>
X<дясна асоциативност>

I<Асоциативността> на оператора определя дали той ще бъде изпълнен
отляво надясно или отдясно на ляво. Събирането е с лява асоциативност,
така че C<2 + 3 + 4> ще изпълни първо C<2 + 3>, а след това ще добави
C<4> към резултата. Повдигането на степен е с дясна асоциативност и
затова в израза C<2 ** 3 ** 4> първо ще се изпълни C<3 ** 4>, а след
това C<2> ще бъде повдигнато на степен 81.

Струва си времето да се запомни приоритетът и асоциативността на често
използваните математически оператори, но винаги ползвайте кръгли скоби
за да няма обърквания.

=begin sidebar

X<C<B::Deparse>>
X<приоритет; пояснителна>
X<асоциативност; пояснителна>

Модулът C<B::Deparse>, който е част от стандартната библиотека с
модули на Perl, е незаменим инструмент за дебъгване. Стартирайте
C<perl -MO=Deparse,-p> върху парче код за да видите как точно Perl
обработва различните оператори в зависимост от техния приоритет и
асоциативност. Флагът C<-p> добавя допълнителни групиращи скоби, които
често правят редът на изпълнение по-ясен.

Не забравяйте, че оптимизаторът на Perl ще опрости математически
операции като тези в предните примери. За да избегнете това,
използвайте променливи, например C<$x ** $y ** $z>.

=end sidebar

=head2 Arity

Z<arity>

X<arity; брой аргументи>
X<оператори; arity; брой на аргументите>
X<nullary>
X<unary>
X<binary>
X<trinary>
X<listary>

I<Arity> означава броя на аргументите, които един оператор приема.
I<Nullary> оператор е този, който не приема аргументи. I<Unary>
оператор е този, който приема само един аргумент. I<Binary> оператор
е този, който приема два аргумента. I<Trinary> оператор е този, който
приема три аргумента.  I<Listary> оператор е този, който работи върху
списък с аргументи. Документацията за всеки оператор и дадените
примери с него би трябвало да покажат ясно какъв брой аргументи може
да приеме.

Аритметичните оператори са бинарни оператори и обикновено са с лява
асоциация.  В изразът C<2 + 3 - 4> първо се изпълнява операцията
събиране C<2 + 3>; събирането и изваждането имат еднакъв приоритет, а
редът на изпълнението им започва от най-левият оператор, понеже са
бинарни операции и с лява асоциация. Първо ще се изпълни най-левият
оператор с аргументи (C<2> и C<3>), а след това резултата ще участва
като аргумент към оператора C<-> и най-десния аргумент (C<4>).

Новаците в Perl често намират за объркващо използването на списъчни
оператори (особено извиквания на функции) и вложени изрази.  Въпреки,
че скобите често помагат, внимавайте с изрази като следния:

=begin programlisting

    # вероятно има бъг
    say ( 1 + 2 + 3 ) * 4;

=end programlisting

... което принтира стойността C<6> и (може би) резултата от всичко ще
е C<4> (върнатата стойност на C<say> умножена по C<4>). Парсърът на
Perl, с огромно щастие, ще интерпретира скобите като оператори
(L<fixity>), които ограждат аргументите на функцията C<say>, а не като
групиращи скоби, които променят реда на изпълнение.

=head2 Fixity

Z<fixity>
X<fixity>
X<operators; fixity>
X<infix>
X<fixity; infix>
X<prefix>
X<fixity; prefix>
X<postfix>
X<fixity; postfix>
X<circumfix>
X<fixity; circumfix>
X<postcircumfix>
X<fixity; postcircumfix> 

Терминът I<fixity> обозначава позицията на оператора относително към позицията на неговите аргументи:

X<C<.>; infix оператор>
X<C<.=>; infix оператор>
X<C<..>; infix оператор>
X<C<...>; infix оператор>
X<C<=~>; infix оператор>
X<C<!~>; infix оператор>
X<C<|>; infix оператор>
X<C<||>; infix оператор>
X<C<//>; infix оператор>
X<C<|=>; infix оператор>
X<C<||=>; infix оператор>
X<C<//=>; infix оператор>

=over 4

=item * I<Infix> операторите стоят между техните аргументи. Повечето
математически оператори са infix оператори, като например оператора за
умножение в C<$length * $width>.

X<C<\>; prefix оператор>
X<C<~>; prefix оператор>
X<C<++>; prefix оператор>
X<C<-->; prefix оператор>
X<C<+>; prefix оператор>
X<C<->; prefix оператор>
X<C<!>; prefix оператор>
X<C<!!>; prefix оператор>

=item * I<Prefix> операторите стоят пред своите аргументи. I<Postfix>
операторите следват след аргументите си. Тези оператори обикновено
приемат само един аргумент, като например математическото отрицание
(C<-$x>), логическото отрицание (C<!$y>), и увеличение на променливата
след взимането на нейната стойност (C<$z++>).

X<C<()>; circumfix оператор>
X<C<{}>; circumfix оператор>
X<C<[]>; circumfix оператор>
X<C<//>; circumfix оператор>
X<C<``>; circumfix оператор>
X<C<''>; circumfix оператор>
X<C<"">; circumfix оператор>

=item * I<Circumfix> операторите обграждат своите аргументи. Такъв е
случаят с оператора за създаване на анонимен хеш (C<{ ... }>) и
операторите за цитиране (C<qq[ ... ]>).

X<C<()>; postcircumfix оператор>
X<C<{}>; postcircumfix оператор>
X<C<[]>; postcircumfix оператор>

=item * I<Postcircumfix> операторите стоят след някои от аргументи си
и обграждат останалите си аргументи. Например операторите за достъп до
елемент от хеш или масив (C<$hash{$x}> и C<$array[$y]>).

=back
